#' @noRd
get_similarities <- function(path, path_out, ext="jpg"){
  dirs <- list.dirs(path, full.names = TRUE, recursive = FALSE)
  sim_paths <- fs::path(dirs,"sim.csv")
  exists <- fs::file_exists(sim_paths)
  if (any(!exists)){
    lapply(dirs[!exists], function(d){
      image_similarity(path_in = d, path_out = fs::path(d, "sim.csv", ext = ext))
    })
  }
  read_similarities(sim_paths)
}

#' Combine similarities from multiple CSVs
#' @importFrom utils read.csv
#' @noRd
read_similarities <- function(paths){
  xx <- lapply(paths,function(p){
    try({
      xx <- read.csv(p)
      colnames(xx)[1] <- "image2"
      xx
    })
  })
  errors <- sapply(xx, function(x) inherits(x,"try-error"))
  if (any(errors)){
    xx <- xx[!errors]
  }
  do.call(rbind, xx)
}

#' Identify breakpoints in single csv
#' @param x A \code{data.frame} with structural similarity values generated by
#' the \code{image_similarity} function.
#' @param cutoff Similarity threshold.
#' @param check_lt Number of images to trigger secondary check.
#' @param cutoff2 Secondary similarity threshold for secondary check.
#' @noRd
find_breakpoints <- function(x, cutoff = .9, check_lt = 13, cutoff2 = .85,
                             interactive = FALSE){
  if (any(is.na(x$similarity))){
    x <- x[-which(is.na(x$similarity)),]
  }
  vals <- x$similarity
  x$group <- cumsum(vals < cutoff) + 1
  if (!is.null(check_lt)){
    x <- check_short_runs(x, check_lt = check_lt, cutoff = cutoff2,
                         interactive = interactive)
  }
  x$img <- as.numeric(stringr::str_split_fixed(
    fs::path_ext_remove(basename(x$image2)), "_", n=2)[,2])
  x
}

#' Identify stack breakpoints
#' @param path Directory containing images.
#' @param cutoff Similarity threshold.
#' @param check_lt Minimum number of images in stack to trigger secondary check.
#' @param cutoff2 Secondary similarity threshold for secondary check.
#' @param interactive Boolean. Whether to do interactive checking. Requires
#' specification of \code{check_gt}.
#' @param check_gt Maximum number of images to trigger secondary check when
#' \code{verbose} is \code{TRUE}.
#' @param ext File extension. Defaults to \code{"jpg"}.
#' @param verbose Boolean. Whether to print verbose output to console.
#' @export
identify_stacks <- function(path, cutoff = .9, check_lt = 13, cutoff2 = .85,
                            interactive = FALSE, check_gt = 25, ext = "jpg",
                            verbose = getOption("verbose")){
  if (interactive){
    check_for_pkg("imager")
  }
  sim <- get_similarities(path, ext = ext)
  sim <- find_breakpoints(sim)
  if (any(is.na(sim$similarity))){
    sim <- sim[-which(is.na(sim$similarity)),]
  }
  vals <- sim$similarity
  sim$group <- cumsum(vals < cutoff) + 1
  if (!is.null(max)){
    sim <- check_short_runs(sim, check_lt = check_lt, cutoff = cutoff2)
  }
  if (interactive && !is.null(check_gt)){
    sim <- check_long_runs(sim, max = check_gt, verbose = verbose)
  }
  sim$img <- as.numeric(stringr::str_split_fixed(
    fs::path_ext_remove(basename(sim$image2)), "_", n=2)[,2])
  sim
}


#' Check short runs
#' Consider combining short stacks
#' @noRd
check_short_runs <- function(x, check_lt, cutoff, interactive= FALSE){
  consec <- cumsum(diff(which(table(x$group) < 10)) != 1) + 1
  for (i in unique(consec)){
    grps <- names(consec[consec == i])
    idx <- which(x$group %in% names(consec[consec == i]))
    gr <- cumsum(x[idx, "similarity"] < cutoff) + 1
    x[idx,"group"] <- grps[gr]
  }
  x
}

#' @noRd
check_long_runs <- function(x, max=25, verbose = TRUE){
  grps <- names(which(table(x$group)>max))
  for (gr in unique(grps)){
    try({
      idx <- which(x$group %in% gr)
      img1 <- x[idx[-1],"image2"][which.min(x[idx[-1],"similarity"])-1]
      img2 <- x[idx[-1],"image2"][which.min(x[idx[-1],"similarity"])]
      if (verbose){
        message(paste0("Group ", gr, ":", " ",
                       basename(img1), " \U2013 ", basename(img2)))
      }
      ln <- compare_images(image1 = img1, image2 = img2)
      if (ln == "y"){
        x <-zs_split_at(x = x, at=img2)
      }
    })
  }
  x
}

#' @importFrom utils tail
#' @noRd
zs_split_at <- function(x, at, col="image2"){
  for (a in at){
    idx <- which(x[,col] == a)
    gr <- x[(idx), "group"]
    x[idx:tail(which(x$group == gr), 1), "group"] <- paste(gr, "1", sep = ".")
  }
  x
}

#' @noRd
compare_images <- function(image1, image2, res = 0.1){
  img <- imager::load.image(image1)
  thmb1 <- imager::resize(img, size_x = round(imager::width(img)*res),
                               size_y = round(imager::height(img)*res))
  img <- imager::load.image(image2)
  thmb2 <- imager::resize(img, size_x = round(imager::width(img)*res),
                          size_y = round(imager::height(img)*res))
  plot(imager::imappend(list(thmb1,thmb2),"x"), axes=FALSE,
       main=paste(basename(image1),basename(image2),sep=" \U2013 "))

  ln <- readline("Split ? (y/n)")
  if (ln %in% c("y","Y","yes","Yes","YES")){
    return("y")
  } else{
    return("n")
  }
}

#' Check for suggested package
#'
#' This function checks for a suggested package and returns an error if the
#' package is not installed (if \code{return_boolean} is FALSE. Otherwise, it
#' returns a boolean value.
#'
#' @noRd
check_for_pkg <- function(pkg, return_boolean = FALSE){
  pkg_exists <- requireNamespace(pkg, quietly = TRUE)
  if (return_boolean){
    return(pkg_exists)
  } else if (!pkg_exists) {
    stop(paste(
      "Package", sQuote(pkg), "must be installed to perform this action:
          try", paste0("`install.packages('", pkg, "')`.")),
      call. = FALSE
    )
  }
}
