#' @noRd
get_similarities <- function(path, path_out, ext="jpg"){
  dirs <- list.dirs(path, full.names = TRUE, recursive = FALSE)
  sim_paths <- fs::path(dirs,"sim.csv")
  exists <- fs::file_exists(sim_paths)
  if (any(!exists)){
    lapply(dirs[!exists], function(d){
      image_similarity(path_in = d, path_out = fs::path(d, "sim.csv", ext = ext))
    })
  }
  read_similarities(sim_paths)
}

#' Combine similarities from multiple CSVs
#' @importFrom utils read.csv
#' @noRd
read_similarities <- function(paths){
  xx <- lapply(paths,function(p){
    try({
      xx <- read.csv(p)
      colnames(xx)[1] <- "image2"
      xx
    })
  })
  errors <- sapply(xx, function(x) inherits(x,"try-error"))
  if (any(errors)){
    xx <- xx[!errors]
  }
  do.call(rbind, xx)
}

#' Identify breakpoints in single csv
#' @param x A \code{data.frame} with structural similarity values generated by
#' the \code{image_similarity} function.
#' @param cutoff Similarity threshold. Defaults to \code{0.9}.
#' @param check_lt Number of images to trigger secondary check. Defaults to \code{13}.
#' @param cutoff2 Secondary similarity threshold for secondary check. Defaults to \code{0.85}.
#' @noRd
find_breakpoints <- function(x, cutoff = .9,
                             interactive = FALSE){
  if (any(is.na(x$similarity))){
    x <- x[-which(is.na(x$similarity)),]
  }
  vals <- x$similarity
  x$group <- cumsum(vals < cutoff) + 1
  x
}

#' Identify stack breakpoints
#' @param path Directory containing images.
#' @param cutoff Similarity threshold. Defaults to \code{0.9}.
#' @param check_lt Number of images to trigger secondary check.
#' Defaults to \code{13}.
#' @param cutoff2 Secondary similarity threshold for secondary check.
#' Defaults to \code{0.85}.
#' @param interactive Boolean. Whether to do interactive checking. Requires
#' specification of \code{check_gt}.
#' @param check_gt Maximum number of images to trigger secondary check when
#' \code{verbose} is \code{TRUE}.
#' @param ext File extension. Defaults to \code{"jpg"}.
#' @param verbose Boolean. Whether to print verbose output to console.
#' @export
identify_stacks <- function(path, cutoff = 0.9, check_lt = 8, cutoff2 = 0.85,
                            interactive = FALSE, check_gt = 25, ext = "jpg",
                            verbose = getOption("verbose")){
  if (interactive){
    check_for_pkg("imager")
  }
  sim <- get_similarities(path, ext = ext)
  if (any(is.na(sim$similarity))){
    sim <- sim[-which(is.na(sim$similarity)),]
  }
  sim <- find_breakpoints(sim)
  # vals <- sim$similarity
  # sim$group <- cumsum(vals < cutoff) + 1
  if (!is.null(max)){
    sim <- check_short_runs(sim, check_lt = check_lt, cutoff = cutoff2)
  }
  if (interactive && !is.null(check_gt)){
    sim <- check_long_runs(sim, max = check_gt, verbose = verbose)
  }
  sim$img <- as.numeric(stringr::str_split_fixed(
    fs::path_ext_remove(basename(sim$image2)), "_", n=2)[,2])
  sim
}


#' Check short runs
#' Consider combining short stacks
#' @noRd
check_short_runs <- function(x, check_lt, cutoff, interactive= FALSE){
  consec <- cumsum(diff(which(table(x$group) < check_lt)) != 1) + 1
  consec <- consec[consec %in% names(which(table(consec) > 1))]
  for (i in unique(consec)){
    grps <- names(consec[consec == i])
    idx <- which(x$group %in% names(consec[consec == i]))
    gr <- cumsum(x[idx, "similarity"] < cutoff) + 1
    x[idx,"group"] <- grps[gr]
  }
  x
}

#' @noRd
check_long_runs <- function(x, max = 25, verbose = getOption("verbose")) {
  skip <- character(0)

  while (TRUE) {
    long_groups <- names(which(table(x$group) > max))
    long_groups <- setdiff(long_groups, skip)

    if (length(long_groups) == 0) break

    for (gr in unique(long_groups)) {
      tryCatch({
        idx <- which(x$group == gr)
        similarities <- x$similarity[idx[-1]]
        min_similarity_index <- which.min(similarities)

        img1 <- x$image2[idx[min_similarity_index]]
        img2 <- x$image2[idx[min_similarity_index + 1]]

        if (verbose) {
          message(sprintf("Group %s: %s \U2013 %s", gr, basename(img1), basename(img2)))
        }

        if (compare_images(image1 = img1, image2 = img2) == "y") {
          x <- zs_split_at(x = x, at = img2)
        } else {
          skip <- c(skip, gr)
        }
      }, error = function(e) {

        warning(sprintf("Error processing group %s: %s", gr, e$message))
      }, finally = skip <- c(skip, gr))
    }
  }
  return(x)
}

#' @importFrom utils tail
#' @noRd
zs_split_at <- function(x, at, col = "image2"){
  for (a in at){
    idx <- which(x[,col] == a)
    gr <- x[(idx), "group"]
    new_group <- add_decimal(x[tail(which(x$group == gr), 1), "group"])
    while (new_group %in% x$group){
      new_group <- add_decimal(new_group)
    }
    x[idx:tail(which(x$group == gr), 1), "group"] <- new_group
  }
  x
}

#' @noRd
add_decimal <- function(x){
  as.character(as.numeric(x) + 0.1)
}

#' @noRd
compare_images <- function(image1, image2, res = 0.1){
  img <- imager::load.image(image1)
  thmb1 <- imager::resize(img, size_x = round(imager::width(img)*res),
                               size_y = round(imager::height(img)*res))
  img <- imager::load.image(image2)
  thmb2 <- imager::resize(img, size_x = round(imager::width(img)*res),
                          size_y = round(imager::height(img)*res))
  plot(imager::imappend(list(thmb1, thmb2),"x"), axes=FALSE,
       main = paste(basename(image1), basename(image2), sep=" \U2013 "))

  ln <- readline("Split ? (y/n)")
  if (ln %in% c("y","Y","yes","Yes","YES")){
    return("y")
  } else{
    return("n")
  }
}

#' Check for suggested package
#'
#' This function checks for a suggested package and returns an error if the
#' package is not installed (if \code{return_boolean} is FALSE. Otherwise, it
#' returns a boolean value.
#'
#' @noRd
check_for_pkg <- function(pkg, return_boolean = FALSE){
  pkg_exists <- requireNamespace(pkg, quietly = TRUE)
  if (return_boolean){
    return(pkg_exists)
  } else if (!pkg_exists) {
    stop(paste(
      "Package", sQuote(pkg), "must be installed to perform this action:
          try", paste0("`install.packages('", pkg, "')`.")),
      call. = FALSE
    )
  }
}
